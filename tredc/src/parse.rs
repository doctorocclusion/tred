# [ derive ( Clone , Debug ) ] pub enum Token { Expr ( ::std::option::Option<::std::boxed::Box<Token>> , ::std::vec::Vec<::std::boxed::Box<Token>> ) , Comment ( ::std::string::String ) , Name ( ::std::string::String ) , Tuple ( ::std::option::Option<::std::boxed::Box<Token>> , ::std::vec::Vec<::std::boxed::Box<Token>> ) , Regex ( ::std::string::String ) , StrLiteral ( ::std::string::String ) , Block ( ::std::vec::Vec<::std::boxed::Box<Token>> ) , } pub fn parse ( input : & str ) -> Result < ::std::vec::Vec<::std::boxed::Box<Token>> , :: tredlib :: ParseErr > { match _blockfn_0 ( 0usize , input , & [ ] ) { Result :: Ok ( ( _ , tree ) ) => Result :: Ok ( tree ) , Result :: Err ( err ) => Result :: Err ( err ) , } } lazy_static ! { static ref _REGEX_20 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^([^\"\\\\]|(\\\\.))*" ) . unwrap ( ) ; static ref _REGEX_36 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^[^\\n]*" ) . unwrap ( ) ; static ref _REGEX_1 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^[\\s\\n\\r]+" ) . unwrap ( ) ; static ref _REGEX_25 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^([^/\\\\]|(\\\\.))*" ) . unwrap ( ) ; static ref _REGEX_0 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^[\\s\\n\\r]*" ) . unwrap ( ) ; static ref _REGEX_4 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^[\\w_]+" ) . unwrap ( ) ; static ref _REGEX_33 : :: tredlib :: regex :: Regex = :: tredlib :: regex :: Regex :: new ( "^\\s*" ) . unwrap ( ) ; } fn _blockfn_0 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_all ! ( _at , _text , _resvec_48 , { _out . append ( _resvec_48 ) ; } , _blockfn_9 ( _at , _text , _inner ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_1 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_not ! ( _at , _text , _resvec_2 , { } , _tredgen_match_str ! ( _at , _text , "_" ) ) ; let mut _start_3 : usize ; _start_3 = _at ; _tredgen_append ! ( _at , _resvec_5 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_4 ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Name ( _text [ _start_3 .. _at ] . to_owned ( ) ) ) ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_2 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_not ! ( _at , _text , _resvec_6 , { } , _tredgen_match_str ! ( _at , _text , "_" ) ) ; let mut _start_7 : usize ; _start_7 = _at ; _tredgen_append ! ( _at , _resvec_9 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_4 ) ? ) ; let mut _acc_10 = _text [ _start_7 .. _at ] . to_owned ( ) ; let mut _intolist_11 = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_12 , { _intolist_11 . append ( _resvec_12 ) ; } , _tredgen_match_str ! ( _at , _text , "(" ) ? ) ; _tredgen_append ! ( _at , _resvec_13 , { _intolist_11 . append ( _resvec_13 ) ; } , _tredgen_match_regex ! ( _at , _text , _REGEX_0 ) ? ) ; _tredgen_some ! ( _at , _text , _resvec_14 , { _intolist_11 . append ( _resvec_14 ) ; } , _blockfn_10 ( _at , _text , _inner ) , _tredgen_match_regex ! ( _at , _text , _REGEX_1 ) ) ; _tredgen_append ! ( _at , _resvec_16 , { _intolist_11 . append ( _resvec_16 ) ; } , _tredgen_match_regex ! ( _at , _text , _REGEX_0 ) ? ) ; _tredgen_append ! ( _at , _resvec_17 , { _intolist_11 . append ( _resvec_17 ) ; } , _tredgen_match_str ! ( _at , _text , ")" ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Tuple ( Some ( :: std :: boxed :: Box :: new ( Token :: Name ( _acc_10 . clone ( ) ) ) ) , _intolist_11 . clone ( ) ) ) ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_3 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_18 , { } , _tredgen_match_str ! ( _at , _text , "\"" ) ? ) ; let mut _start_19 : usize ; _start_19 = _at ; _tredgen_append ! ( _at , _resvec_21 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_20 ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: StrLiteral ( _text [ _start_19 .. _at ] . to_owned ( ) ) ) ) ) ; _tredgen_append ! ( _at , _resvec_22 , { } , _tredgen_match_str ! ( _at , _text , "\"" ) ? ) ; Ok ( ( _at , _out ) ) } fn _blockfn_4 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_23 , { } , _tredgen_match_str ! ( _at , _text , "/" ) ? ) ; let mut _start_24 : usize ; _start_24 = _at ; _tredgen_append ! ( _at , _resvec_26 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_25 ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Regex ( _text [ _start_24 .. _at ] . to_owned ( ) ) ) ) ) ; _tredgen_append ! ( _at , _resvec_27 , { } , _tredgen_match_str ! ( _at , _text , "/" ) ? ) ; Ok ( ( _at , _out ) ) } fn _blockfn_5 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; let mut _intolist_28 = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_29 , { _intolist_28 . append ( _resvec_29 ) ; } , _tredgen_match_str ! ( _at , _text , "{" ) ? ) ; _tredgen_some ! ( _at , _text , _resvec_30 , { _intolist_28 . append ( _resvec_30 ) ; } , _blockfn_9 ( _at , _text , _inner ) ) ; _tredgen_append ! ( _at , _resvec_31 , { _intolist_28 . append ( _resvec_31 ) ; } , _tredgen_match_str ! ( _at , _text , "}" ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Block ( _intolist_28 . clone ( ) ) ) ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_6 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_32 , { } , _tredgen_match_str ! ( _at , _text , "//" ) ? ) ; _tredgen_append ! ( _at , _resvec_34 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_33 ) ? ) ; let mut _start_35 : usize ; _start_35 = _at ; _tredgen_append ! ( _at , _resvec_37 , { } , _tredgen_match_regex ! ( _at , _text , _REGEX_36 ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Comment ( _text [ _start_35 .. _at ] . to_owned ( ) ) ) ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_7 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_or ! ( _at , _text , _resvec_38 , { _out . append ( _resvec_38 ) ; } , _blockfn_3 ( _at , _text , _inner ) , _blockfn_4 ( _at , _text , _inner ) , _blockfn_5 ( _at , _text , _inner ) , _blockfn_2 ( _at , _text , _inner ) , _blockfn_1 ( _at , _text , _inner ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_8 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; let mut _intoonce_39 = None ; _tredgen_append ! ( _at , _resvec_40 , { _intoonce_39 = _resvec_40 . pop ( ) . or ( _intoonce_39 ) ; } , _blockfn_7 ( _at , _text , _inner ) ? ) ; let mut _intolist_41 = :: std :: vec :: Vec :: new ( ) ; _tredgen_some ! ( _at , _text , _resvec_42 , { _intolist_41 . append ( _resvec_42 ) ; } , _blockfn_11 ( _at , _text , _inner ) ) ; _tredgen_append ! ( _at , _resvec_45 , { _intolist_41 . append ( _resvec_45 ) ; } , _tredgen_match_regex ! ( _at , _text , _REGEX_0 ) ? ) ; _tredgen_append ! ( _at , _resvec_46 , { _intolist_41 . append ( _resvec_46 ) ; } , _tredgen_match_str ! ( _at , _text , ";" ) ? ) ; _out . extend ( Some ( :: std :: boxed :: Box :: new ( Token :: Expr ( _intoonce_39 . clone ( ) , _intolist_41 . clone ( ) ) ) ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_9 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_or ! ( _at , _text , _resvec_47 , { _out . append ( _resvec_47 ) ; } , _tredgen_match_regex ! ( _at , _text , _REGEX_1 ) , _blockfn_6 ( _at , _text , _inner ) , _blockfn_8 ( _at , _text , _inner ) ) ; Ok ( ( _at , _out ) ) } fn _blockfn_10 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_15 , { _out . append ( _resvec_15 ) ; } , _blockfn_7 ( _at , _text , _inner ) ? ) ; Ok ( ( _at , _out ) ) } fn _blockfn_11 ( _start : usize , _text : & str , _inner : & [ :: std :: boxed :: Box < Token > ] ) -> Result < ( usize , ::std::vec::Vec<::std::boxed::Box<Token>> ) , :: tredlib :: ParseErr > { let mut _at = _start ; let mut _out = :: std :: vec :: Vec :: new ( ) ; _tredgen_append ! ( _at , _resvec_43 , { _out . append ( _resvec_43 ) ; } , _tredgen_match_regex ! ( _at , _text , _REGEX_1 ) ? ) ; _tredgen_append ! ( _at , _resvec_44 , { _out . append ( _resvec_44 ) ; } , _blockfn_7 ( _at , _text , _inner ) ? ) ; Ok ( ( _at , _out ) ) }
